:idprefix:
:icons: font
:encoding: utf-8
:lang: en-US
:sectanchors: true
:sectlinks: true
:linkattrs: true
:jbake-permalink: gradle-project-layout
:jbake-id: {jbake-permalink}
= Gradle Project Layout
Daniel Lacasse
2020-06-30
:jbake-type: blog_post
:jbake-status: unpublished
:jbake-tags: blog
//:jbake-description: Announcing the Nokee plugin suite, a continuous effort for painless native development in Gradle.
//:jbake-leadimage: hello-native-presentation.png
//:jbake-leadimagealt: Announcing the Nokee plugin suite
//:jbake-twitter: { "creator": "@lacasseio", "card": "summary_large_image" }

Most build systems use the file system as the project layout.
It's most notably the case for Make-based build system. footnote:[Technically, Make don't have a concept of projects, but most developers write their _project_ modelling on top, which are mostly file-based.]
The file system-based project modelling approach is quick and easy to implement.
It relies on a simple check with the file system, and off the build goes.

However, it's not a magic solution as it can be.
What happens when projects are deeply nested?
Or when we move projects around?
Or when we deal with legacy tools assuming a specific layout?
The solutions are often unimaginative and simply work around the core issue.
For example, native projects often prefer a flat layout.
Developers split the includes, binaries, and source codes into top-level folders.

Gradle has a distinct model for the project layout and on-disk layout.
By convention, both follow the same layout, e.g. project `:foo` is in folder `foo`.
However, we can configure Gradle to use two different layouts.
The Nokee project https://github.com/nokeedev/gradle-native/blob/ceccbc982c571fa6fde913dafb255f19ad64894a/settings.gradle#L52-L54[remap all projects inside the _subprojects_ folders].
The project folders follow a kebab convention, which differs from the project name, following a lowerCamelCase convention.

Gradle doesn't stop there.
We can change the source layout convention, from the well-known Maven layout to something completely different.
We can relocate the build directory anywhere we want.
It renders the argument of in-source build vs out-source build irrelevant as Gradle can do both, or an hybrid or something completely crazy.
The point is, Gradle is much more flexible than everyone is using it.

With all this flexibility offered by Gradle, there isn't an optimal project layout.
It depends on your projects.
Here are some guidelines to help you choose the right project layout.

== Focus on *what* you are building instead of _how_

Identifying the building blocks inside your repository will help create the project layout.
Whether your organization follows a mono-repo or multi-repo or whatever the on-disk source layout may be, there are always holistic building blocks to your projects.
Each of those blocks is a project.
Some of those blocks may only make sense together; make a note of them.

Some questions that can help you are:

- What kind of component is your build producing? Application? Library? Something else?
- What are you distributing to your clients? RPM? Zip archives?
- What is the relationship between your components? 3rd party libraries build from sources? Helper tools?
- What are the artifacts produced? For other projects? For testing?

== Make your developers happy

Identifying which building blocks are essential to your developers will help establish an efficient project layout.
The developers are the users of the build.
The build system needs to work with them.
They also know which projects as well as which actions they require for their daily work.

For example, the holistic project layout may favour deep nesting of the projects.
However, the developer may only care about executing test coverage for a project subset.
It's not about solving the deep nesting of projects but rather providing tasks to allow smooth test coverage execution.
Or maybe offer an umbrella project that exposes an aggregated set of actions for a subset of projects.

NOTE: Did you know Gradle creates intermediate projects in your hierarchy?
For example, `include 'a:b:c'` creates a project `:a`, project `:a:b` and project `:a:b:c`.
Project `:a` could contain convenient tasks that act on its subprojects.
Then developer could execute `./gradlew :a:foo` which would apply to project :a:b and project `:a:b:c`.

== Not all projects needs a build script

Some build systems identify projects by the presence of a build script.
Gradle configures projects as declared in the settings.gradle[.kts] file.
Whether the project build script exists or not, the project still exists and is configurable.

NOTE: Did you know Gradle can inject configuration code inside any projects?
`project(path, Action)`, `subprojects(Action)` and `allprojects(Action)` are great ways to configure other projects than the currently configuring projects.
For example, you could use a single build.gradle to configure multiple projects:
----
include 'a:b1'
include 'a:b2'
include 'a:b3'
----
----
project('b1') {
    //configure b1
}
project('b2') {
    //configure b2
}
project('b3') {
    // configure b3
}
----
You could even model the `b*` projects inside project `:a` with an extension.

== Prefer convention-over-configuration

The convention is always much more powerful than configuring each project individually.
Suppose a C++ library project is defined by the presence of C++ source files located by convention in `src/main/cpp`.
We could have something like this in the root build script:

----
allprojects {
    if (file('src/main/cpp').exists) {
        apply plugin: 'dev.nokee.cpp-library'
    }
}
----

These four lines of code may apply to 100s of projects.
There was no need to create `build.gradle` files in those 100s of projects.

Now suppose some of those C++ library projects are in fact applications, we could build a look aside list of those _exceptions_ and barely make the configuration anymore complicated:

----
def applicationProjects = [':foo', ':bar']
allprojects {
    if (file('src/main/cpp').exists) {
        if (applicationProjects.contains(path)) {
            apply plugin: 'dev.nokee.cpp-application'
        } else {
            apply plugin: 'dev.nokee.cpp-library'
        }
    }
}
----

If by convention, application projects have an `App` suffix, we don't need the lookaside list.
It may be tempting to nest applications and libraries under umbrella projects to allow easy configurations such as `project(':lib').subprojects { ... }`.
Experience has shown it's usually better to avoid this kind of configuration.
There are some cases where it makes sense.

NOTE: Did you know each build script is a Turin-complete language?
You can write modelling code as you see fit.
For example, suppose your project has 1000s of projects, but they all follow a similar on-disk convention layout.
You could write a file system walker to discover every project.
Since Gradle is JVM-based, you can use the https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#walkFileTree-java.nio.file.Path-java.nio.file.FileVisitor-(`Files#walkFileTree` API) for this purpose.
There are some performance considerations, but we can mitigate them one way or another.

//== Prefer engineering your build instead of scripting



//In those cases, you may want to model them as a single entity which could be seen as meta-projects.
//
//
//
//
//
//
//Most build system as file based, meaning the build layout is the same as the file system layout.
//Gradle makes a distinction between both layer.
//It means Gradle has a virtual view of your projects which then map to the file system.
//It's the reason why your project source layout matters little to Gradle as it can map any layout (provided the plugins doesn't make hard assumption, in general production ready plugin will not make any).
//The war of in-source vs out-source build system is irrelevant in Gradle as it can do both, or an hybride or something completely crazy if you want.
//
//The idea is not novel, in networking, we can connect computers half way around the earth as if they were connected physically to the same switch.
//
//Misconception #1, the multi project include much match your project file layout
//
//Wrong. The include simply states to gradle that project with the specified project path existed, virtually that is.
//It generally when the mapping is one to oneish with the file system but it is not an hard requirement.
//
//In fact when, you can include a project that doesn't exists on-disk like:
//...
//
//Gradle does not care. It assume a missing files as an empty project configuration.
//
//Misconception #2 each project must have a build script file
//
//No it doesn't need to. Empty file == no build configuration from that file. You can configure project from other projects.
//project(:abs:path)...
//
//Or relative path project(:rel:path")
//
//You can even target subprojects from any point in the project virtual graph. Subprojects applies to the Gradle representation vs on disk layout.
//
//Misconception #3, a project is needed for each folder containing code
//
//No it is really about what you are building.
//
//Misconception #4, the project name must mstch a directory name
//No, Gradle logic is to use kebab case for all folder name but lowerCamelCase for all project name. Also the projects are located in subprojects on disk but are referenced directly by name.
//
//Misconception #5 execution must always be done from the subproject
//When I first started, I used to always cd in project directory then execute my Gradle command. Typically you execute your Gradle command from the root of your project. You can use :path:to:task (abs) or path:to:task (relative). From a subdirectory, you can "go up in the project hiarchy" by mixing abs vs rel.
//
//
//Regardless of the feature Gradle provides, you should think about what ate you trying to model and build, not how to do it. What is the component and how they group and connect (virtual) how is pushing bytes (physical).
